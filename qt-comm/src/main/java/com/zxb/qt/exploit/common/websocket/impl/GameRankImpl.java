package com.zxb.qt.exploit.common.websocket.impl;

import com.zxb.qt.exploit.common.anno.CurrentUserAnno;
import com.zxb.qt.exploit.common.anno.game.CuUser2RGameObjAnno;
import com.zxb.qt.exploit.common.boot.utils.JsonUtils;
import com.zxb.qt.exploit.common.redis.RedisUtils;
import com.zxb.qt.exploit.common.websocket.GameRank;
import com.zxb.qt.exploit.entity.Games;
import com.zxb.qt.exploit.entity.User;
import com.zxb.qt.exploit.entity.vo.GameRedisVO;
import com.zxb.qt.exploit.entity.vo.GameVO;
import com.zxb.qt.exploit.entity.vo.TypedTupleRangVO;
import com.zxb.qt.exploit.mapper.GamesMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Primary;
import org.springframework.data.redis.core.ZSetOperations;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

/**
 *  排行榜 功能实现
 *  1. 分页显示排行榜数据
 *  2. 成功完成一把游戏 记录游戏时间 并返回成功游戏后的排名信息
 *  3. 查找与自己排行相近的用户排行信息
 */
@Primary
@Component
public class GameRankImpl implements GameRank {

    private ZSetOperations zset;
    private RedisUtils redisUtils;

    @Autowired
    private GamesMapper gameMapper;

    @Autowired
    public GameRankImpl( RedisUtils redisUtils ){
        this.redisUtils = redisUtils;
        zset = redisUtils.opsZSet();
    }

    @Override
    @CuUser2RGameObjAnno
    public GameVO insertOrUpdate(String key, Games games , GameRedisVO user ) {
        //保证ID 无论如何都存在
        if ( games.getId() == null ){
            games.setUserId( user.getId() );
            gameMapper.insert( games );
        }
        String v = JsonUtils.obj2String( user );

        GameVO gameVO = new GameVO();
        //获取ID
        Long id = games.getId() ;
        //用户本局游戏闯关时间
        Double sorts = games.getTall();
        //用户历史最高
        Double d =  zset.score( key , v );
        //用户当前排名
        Long currRank = null;


        //判断该用户排名信息是否存在缓存中
        if ( d != null && sorts > d  ){
            //时间越短 成绩越好
            //如果新纪录 小于 历史最高，不做修改
        }else{
            //如果新纪录 大于历史最高或则是redis中不存在该数据 新增或修改
            //存入redis
            zset.add( key , v , sorts );
            //因为新纪录已经超过 修改历史最高
            games.setTall( sorts );
            gameMapper.updateById( games );
            d = sorts ;
        }
        currRank = zset.rank( key , v ) ;
        //返回用户当前排名信息
        gameVO.setHistoryTall( d.intValue()   );
        gameVO.setCurrentTall( sorts.intValue() );
        gameVO.setRank( currRank );
        return gameVO ;
    }

    @Override
            public List<TypedTupleRangVO> topRange(String key, long left, long right) {
                if ( left < 0  ){
                    left = 0 ;
            right = 10;
        }
        Set set = zset.rangeWithScores( key , left , right );

        return buildListRangVO( set , left );
    }

    @Override
    public Long sizeRange( String key ) {
        return zset.size( key );
    }

    public List<TypedTupleRangVO> buildListRangVO(Set<ZSetOperations.TypedTuple<String>> result, long offset ){
        List arr = new ArrayList( result.size() );
        for ( ZSetOperations.TypedTuple data : result ){
            arr.add( new TypedTupleRangVO( data.getScore() , offset++ , data.getValue() ) );
        }
        return arr;
    }

    @Override
    public Set<GameVO> thisRange(String key, long l1, long l2) {
        return null;
    }

}
