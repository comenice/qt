package com.zxb.qt.exploit.common.shiro.realm;

import com.baomidou.mybatisplus.core.conditions.Wrapper;
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.zxb.qt.exploit.common.boot.exception.BlogException;
import com.zxb.qt.exploit.entity.SysRole;
import com.zxb.qt.exploit.entity.User;
import com.zxb.qt.exploit.entity.vo.RoleRightVO;
import com.zxb.qt.exploit.entity.vo.UserRoleVO;
import com.zxb.qt.exploit.mapper.SysRightMapper;
import com.zxb.qt.exploit.mapper.SysRoleMapper;
import com.zxb.qt.exploit.mapper.UserMapper;
import org.apache.shiro.authc.*;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.authz.SimpleAuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;
import org.apache.shiro.util.ByteSource;
import org.junit.Test;
import org.springframework.beans.factory.annotation.Autowired;

import javax.annotation.Resource;
import java.util.*;


/**
 *  shiro 的对用户的授权和验证 这两种组成了realm
 */

public class CustRealm extends AuthorizingRealm {


    /**
     * 我的Mapper 无法通过 springIoc 容器注入
     * 原因是 我的CustRealm类 并不是通过注解注入的
     * 而是直接new CustRealm() 所以导致无法注入 给该类添加@Bean注解 解决问题
     */

    @Autowired
    private UserMapper userMapper;
    @Autowired
    private SysRightMapper sysRightMapper;
    @Autowired
    private SysRoleMapper sysRoleMapper;


    //认证
    //认证用户
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        System.out.println("CustRealm.doGetAuthenticationInfo()");
        //获取用户的输入的账号.
        String username = (String)token.getPrincipal();
        User userInfo = null;
        //通过username从数据库中查找 User对象，如果找到，没找到.
        //实际项目中，这里可以根据实际情况做缓存，如果不做，Shiro自己也是有时间间隔机制，2分钟内不会重复执行该方法
        userInfo = selectOneUserByName( username );

        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(
                userInfo, //用户名
                userInfo.getPassWord(), //密码
                ByteSource.Util.bytes(userInfo.getSalt()),
                getName()//realm 可以使用 CustRealm 在存在多个CustRealm时使用 getName(); 形成realm链
        );
        return authenticationInfo;
    }




    private User selectOneUserByName( String userName ) {
        User user = null;
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        Wrapper<User> wrapper = queryWrapper.eq("USER_NAME", userName);
        user = userMapper.selectOne( wrapper );

        if ( user == null ){
            throw new UnknownAccountException( "账号不存在 !" );
        }
        if ( user.getAccountLock() == null | "1".equals( user.getAccountLock() ) ){
            throw new BlogException( "-1" , "账号已经被锁定" );
        }
        return user;
    }

    //授权
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        System.out.println( "CustRealm.doGetAuthorizationInfo()" );
        //得到 用户
        User user = (User) principalCollection.getPrimaryPrincipal();
        //得到用户输入的用户名 查询是否拥有权限
        String userName = user.getUserName() ;
        //QueryWrapper 条件构造器   wrapper 装饰者设计模式 加强原有的方法
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        //得到条件
        Wrapper<User> wrapper = queryWrapper.eq("USER_NAME", userName);

        //查询 用户
        User u = userMapper.selectOne(wrapper);
        if ( u == null ){
            return new SimpleAuthorizationInfo();
        }
        //得到用户角色
        UserRoleVO userRoleVO = sysRoleMapper.queryUserRole(u.getId());

        Set<String> roles = new HashSet<String>();
        List<RoleRightVO> rightVOList = new ArrayList<>();

        for (SysRole sysRole:userRoleVO.getSysRoles()){
            roles.add( sysRole.getRole() );
            rightVOList.addAll( sysRightMapper.queryRoleRight( sysRole.getId() ) );
        }

        //返回包装的用户角色权限信息
        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
        info.setRoles( roles );
        info.addStringPermissions( getRight( rightVOList ) );
        return info;
    }

    private Collection<String> getRight(List<RoleRightVO> permissionVOList) {
        List<String> rights = new ArrayList<String>();
        for (RoleRightVO rolePermissionVO : permissionVOList) {
            rights.add(rolePermissionVO.getRoleName());
        }
        return rights;
    }
}
