package com.zxb.qt.exploit.common.shiro;


import com.zxb.qt.exploit.common.shiro.SessionDao.ShiroSessionDao;
import com.zxb.qt.exploit.common.shiro.eache.RedisCacheManager;
import com.zxb.qt.exploit.common.shiro.realm.CustRealm;
import com.zxb.qt.exploit.entity.User;
import org.apache.shiro.authc.credential.HashedCredentialsMatcher;
import org.apache.shiro.authz.UnauthorizedException;
import org.apache.shiro.mgt.SubjectDAO;
import org.apache.shiro.session.mgt.ExecutorServiceSessionValidationScheduler;
import org.apache.shiro.session.mgt.SessionManager;
import org.apache.shiro.session.mgt.ValidatingSessionManager;
import org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO;
import org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator;
import org.apache.shiro.session.mgt.eis.SessionDAO;
import org.apache.shiro.session.mgt.eis.SessionIdGenerator;
import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;
import org.apache.shiro.spring.web.ShiroFilterFactoryBean;
import org.apache.shiro.web.mgt.CookieRememberMeManager;
import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
import org.apache.shiro.web.servlet.SimpleCookie;
import org.apache.shiro.web.session.mgt.DefaultWebSessionManager;
import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.context.annotation.PropertySource;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.filter.DelegatingFilterProxy;

import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;


/**
 *  shiro 的配置类
 */


@Configuration
@PropertySource("classpath:application-comm.properties")
public class ShiroConfig {

    private String loginUrl;
    private String noRightUrl;
    @Value( "${shrio.hash.iterations}" )
    private int iterations; //迭代次数
    @Value( "${shrio.hash.algorithm}" )
    private String algorithm;  //加密类型



    @Autowired
    private RedisTemplate redisTemplate;


    /**
     * session 由
     * 核心:shiroFilter拦截器,ioc容器中的
     *
     * @return filterRegistrationBean
     */
    @Bean( name = "FilterRegistrationBean1")
    public FilterRegistrationBean filterRegistrationBean() {
        FilterRegistrationBean filterRegistration = new FilterRegistrationBean();
        //过滤器
        filterRegistration.setFilter(new DelegatingFilterProxy("shiroFilter"));
        // 该值缺省为false,表示生命周期由SpringApplicationContext管理,设置为true则表示由ServletContainer管理
        filterRegistration.addInitParameter("targetFilterLifecycle", "false");
        filterRegistration.setEnabled(true);
        filterRegistration.addUrlPatterns("/*");
        return filterRegistration;
    }


    @Bean( name = "shiroFilter")
    public ShiroFilterFactoryBean shiroFilter(
                          @Autowired DefaultWebSecurityManager securityManager
                                ) {
        //DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
        // 必须设置 SecurityManager
        //securityManager.setRealm( customRealm() ) ;

        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
        shiroFilterFactoryBean.setSecurityManager(securityManager);
        //setLoginUrl 如果不设置值，默认会自动寻找Web工程根目录下的"/login.jsp"页面 或 "/login" 映射
        shiroFilterFactoryBean.setLoginUrl("/user/");
        // 设置无权限时跳转的 url;
        shiroFilterFactoryBean.setUnauthorizedUrl("/user/");
        //设置拦截器
        Map<String, String> filterChainDefinitionMap = new LinkedHashMap<>();
        //游客，开放权限
       // filterChainDefinitionMap.put("/**", "anon");
        //静态
        filterChainDefinitionMap.put("/common/**", "anon");

        filterChainDefinitionMap.put("/data/**", "anon");
        filterChainDefinitionMap.put("/fx/**", "anon");
       // filterChainDefinitionMap.put("/index.html/**", "role[admin]");
        filterChainDefinitionMap.put("/home.html/**", "anon");
        filterChainDefinitionMap.put("/gallery/**", "anon");
        filterChainDefinitionMap.put("/blog/**", "anon");
        filterChainDefinitionMap.put("/app/**", "anon");
        filterChainDefinitionMap.put( "/custom/**" , "anon" );
        filterChainDefinitionMap.put( "/comment/asynComment" , "anon" );
        filterChainDefinitionMap.put( "/comment/queryReplyinfo" , "anon" );
        filterChainDefinitionMap.put( "/comment/commentBlogUserInfo" , "anon" );
        filterChainDefinitionMap.put( "/comment/star" , "anon" );


        //用户，需要角色权限 “user”
        filterChainDefinitionMap.put("/user/**", "roles[user]");
        //管理员，需要角色权限 “admin”
        filterChainDefinitionMap.put("/admin/**", "roles[admin]");
        //开放登陆接口
        filterChainDefinitionMap.put("/user/**", "anon");
        //其余接口一律拦截
        //主要这行代码必须放在所有权限设置的最后，不然会导致所有 url 都被拦截
//        filterChainDefinitionMap.put("/**", "authc");
        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
        return shiroFilterFactoryBean;
    }


    /**
     * SessionDAO的作用是为Session提供CRUD并进行持久化的一个shiro组件
     * MemorySessionDAO 直接在内存中进行会话维护
     * EnterpriseCacheSessionDAO  提供了缓存功能的会话维护，默认情况下使用MapCache实现，内部使用ConcurrentHashMap保存缓存的会话。
     * @return
     */
//    @Bean
//    public SessionDAO sessionDAO() {
//        EnterpriseCacheSessionDAO enterpriseCacheSessionDAO = new EnterpriseCacheSessionDAO();
//        //使用ehCacheManager
//       enterpriseCacheSessionDAO.setCacheManager( new RedisCacheManager() );
//        //设置session缓存的名字 默认为 shiro-activeSessionCache
//        enterpriseCacheSessionDAO.("shiro-activeSessionCache");
//        //sessionId生成器
//        enterpriseCacheSessionDAO.setSessionIdGenerator(sessionIdGenerator());
//        return enterpriseCacheSessionDAO;
//    }


    /**
     * shiro安装管理器
     *
     * @param cacheManager            缓存管理器
     * @param  cookie管理器
     * @return securityManager
     *
     * 会话管理器管理着应用中所有Subject的会话的创建、维护、删除、失效、验证等工作。
     * 是Shiro的核心组件，顶层组件SecurityManager直接继承了SessionManager，
     * 且提供了SessionsSecurityManager实现直接把会话管理委托给相应的SessionManager。
     * Shiro提供了两个实现：DefaultSecurityManager及DefaultWebSecurityManager。
     *
     */
    /**
     * 安全管理
     * @param cacheManager
     * @return
     */
    @Bean("securityManager")
    public DefaultWebSecurityManager defaultWebSecurityManager(
            @Autowired @Qualifier( "redisCacheManager" )  RedisCacheManager cacheManager ) {
        DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();
        sessionManager.setGlobalSessionTimeout( 604800000 );
        DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager();
        //注入缓存
     //   defaultWebSecurityManager.setCacheManager(cacheManager);
        //注入认证授权Realm
        defaultWebSecurityManager.setRealm( customRealm() );

        //注入会话 管理
       // defaultWebSecurityManager.setSessionManager( sessionManager() );
        //注入记住我
        // @Autowired @Qualifier( "" ) CookieRememberMeManager cookieRememberMeManager
        //defaultWebSecurityManager.setRememberMeManager(cookieRememberMeManager);

        //改变默认的 id名称
        defaultWebSecurityManager.setSessionManager( sessionManager() );
        return defaultWebSecurityManager;
    }

   // @Bean
    public SessionDAO getSessionDao(){
        ShiroSessionDao sessionDao = new ShiroSessionDao();
        //session id 生成
        sessionDao.setSessionIdGenerator(sessionIdGenerator());
        return sessionDao;
    }

    /**
     * 会话管理
     * @return
     */
   // @Bean
    public DefaultWebSessionManager  sessionManager(){
        DefaultWebSessionManager  sessionManager = new DefaultWebSessionManager ();

//        ExecutorServiceSessionValidationScheduler scheduler = new ExecutorServiceSessionValidationScheduler();
//        scheduler.setInterval(200000);
//        scheduler.setSessionManager(sessionManager);
//        sessionManager.setGlobalSessionTimeout(200000);
//        sessionManager.setSessionValidationScheduler(scheduler);
//        //持久化 session 保存在redis中 默认不是这样的
//        sessionManager.setSessionDAO( getSessionDao() );
        sessionManager.setSessionIdCookie( getSIdCookie() );
        return sessionManager;
    }



    /**
     * 配置shiro缓存管理器
     * @return RedisCacheManager
     */
   @Bean(name = "redisCacheManager")
   @Primary
    public RedisCacheManager redisCacheManager() {
        RedisCacheManager cacheManager = new RedisCacheManager();
        cacheManager.setRedisTemplate(redisTemplate);
        return cacheManager;
    }

    /**
     * 自定义身份认证 realm;
     * <p>
     * 必须写这个类，并加上 @Bean 注解，目的是注入 CustomRealm，
     * 否则会影响 CustomRealm类 中其他类的依赖注入
     * shiro密码比对器
     * realm 是由  授权 和 认证组成的
     */
    @Bean
    public CustRealm customRealm() {
        CustRealm custRealm = new CustRealm();
        //设置 认证加密方式
        HashedCredentialsMatcher matcher = new HashedCredentialsMatcher();
        matcher.setHashIterations( iterations );
        matcher.setHashAlgorithmName( algorithm );
        custRealm.setCredentialsMatcher( matcher );
        return custRealm;
    }

    /**
     * 管理cookie 目前只更换了别名
     * @return
     */
    @Bean
    public SimpleCookie getSIdCookie(){
        return new SimpleCookie( "sessionId" );
    }


    /**
     * 配置会话ID生成器
     * @return
     */
    @Bean
    public SessionIdGenerator sessionIdGenerator() {
        return new JavaUuidSessionIdGenerator();
    }

    @Bean
    public DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator() {
        DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();
        advisorAutoProxyCreator.setProxyTargetClass(true);
        return advisorAutoProxyCreator;
    }

    @Bean
    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor() {
        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor();
        authorizationAttributeSourceAdvisor.setSecurityManager( new DefaultWebSecurityManager() );
        return authorizationAttributeSourceAdvisor;
    }



}
