package com.zxb.qt.exploit.common.redis.cache;

import com.zxb.qt.exploit.common.boot.utils.SpringUtils;
import com.zxb.qt.exploit.common.redis.RedisTypeEnum;
import com.zxb.qt.exploit.common.redis.RedisUtils;

import java.util.ArrayList;
import java.util.List;

/**
 * 根据类型区分 各种数据结构  已来获取数据
 */
public interface RedisTypeInData {

    Integer maxInt = Integer.MAX_VALUE ;

    /**
     * @param type 数据结构类型
     * @param key key
     * @param itemOrSE item 或则是 itemOrSE[0] = start itemOrSE[1] =  end
     * @return
     */
   default Object getData( String type , String key , Object... itemOrSE ){
       long start = 0 ;
       long end = 0 ;
       RedisUtils redisUtils = SpringUtils.getBean( RedisUtils.class );
       if (  RedisTypeEnum.HASH.getStrCode().equals( type ) ) {
           List list = new ArrayList( itemOrSE.length );
           for ( int i = 0 ; i < itemOrSE.length ; i++ ){
               list.add(   redisUtils.hget( key , Integer.valueOf( itemOrSE[i].toString().trim() ) ) );
           }
           return list;
       }
       //item可能也是多个数字组成的 所以如果我们要获取区间，那么跳过hash
       try {
           if (  ( end = (int) itemOrSE[1]) >= 0  ) {
               start = (int) itemOrSE[0];
           }
       } catch (ArrayIndexOutOfBoundsException e) {
           e.printStackTrace();
       }
       if (RedisTypeEnum.STRING.getStrCode().equals( type )){
            return redisUtils.get( key );
       }else if ( RedisTypeEnum.LIST.getStrCode().equals( type ) ){
            return redisUtils.lGet( key ,  start , end );
       }else if ( RedisTypeEnum.SET.getStrCode().equals( type ) ){
            return redisUtils.sGet( key );
       }else if ( RedisTypeEnum.ZSET.getStrCode().equals( type ) ){
            return redisUtils.opsZSet().range( key ,start ,end );
       }
       return null;
   }

}
